import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'
import { Asset } from 'expo-asset';
import ExpoTHREE, { Renderer } from 'expo-three';
import { THREE } from 'expo-three';


import * as React from 'react';
import {
    AmbientLight,
    Fog,
    PointLight,
    Scene,
    SpotLight,
    PerspectiveCamera,
    DirectionalLight

} from 'three';
import { GLView } from 'expo-gl';


export default function TasksPage() {

    let timeout;

    React.useEffect(() => {
        // Clear the animation loop when the component unmounts
        return () => clearTimeout(timeout);
    }, []);




    return (
        <GLView
            style={{ flex: 1 }}
            onContextCreate={async (gl) => {
                const { drawingBufferWidth: width, drawingBufferHeight: height } = gl;

                // Create a WebGLRenderer without a DOM element
                const renderer = new Renderer({ gl });
                renderer.setSize(width, height);
                renderer.setClearColor('white');
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap


                const camera = new PerspectiveCamera(70, width / height, 0.01, 1000);
                camera.aspect.valueOf(width / height)
                camera.position.set(1, 5, 5);

                const scene = new Scene();


                const ambientLight = new AmbientLight(0x101010);
                ambientLight.intensity.valueOf(1)
                scene.add(ambientLight);


                const pointLight = new PointLight(0xffffff, 2, 1000, 1);
                pointLight.position.set(10, 10, 10);
                pointLight.castShadow = true

                pointLight.shadow.mapSize.width = 512; // default
                pointLight.shadow.mapSize.height = 512; // default
                pointLight.shadow.camera.near = 0.5; // default
                pointLight.shadow.camera.far = 500; // default




                scene.add(pointLight);


                const composer = new EffectComposer(renderer);


                const asset = Asset.fromModule(require("../../assets/3D/AESLowPolyREADYFORGLTF.obj"));
                await asset.downloadAsync();

                // instantiate a loader
                const loader = new OBJLoader();

                // load a resource
                loader.load(
                    // resource URL
                    asset.localUri,
                    // called when resource is loaded
                    function (object) {



                        object.scale.set(2, 2, 2)
                        scene.add(object);
                        camera.lookAt(object.position)

                        object.castShadow = true
                        object.receiveShadow = true

                        const m2 = new THREE.MeshStandardMaterial({ color: 'orange' });

                        object.traverse((child) => {

                            if (child instanceof THREE.Mesh) {

                                child.material = m2;

                            }

                        })

                        //animate rotation
                        function update() {

                        }
                        const render = () => {
                            timeout = requestAnimationFrame(render);
                            update();
                            renderer.render(scene, camera);
                            gl.endFrameEXP();
                        };

                        render();
                    },

                    // called when loading is in progresses
                    function (xhr) {

                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');

                    },
                    // called when loading has errors
                    function (error) {

                        console.log(error);

                    }

                );
            }}
        />
    );
}